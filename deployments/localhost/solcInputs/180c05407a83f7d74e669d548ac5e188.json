{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IUniswapV3Manager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IUniswapV3Manager {\n    struct MintParams {\n        address poolAddress;\n        int24 lowerTick;\n        int24 upperTick;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n    }\n}"
    },
    "contracts/interfaces/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IUniswapV3MintCallback {\n    function uniswapV3MintCallback(uint256 amount0, uint256 amount1, bytes calldata data) external;\n}"
    },
    "contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IUniswapV3Pool {\n    struct CallbackData {\n        address token0;\n        address token1;\n        address payer;\n    }\n\n    function slot0() external view returns (uint160 sqrtPriceX96, int24 tick);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function mint(\n        address owner,\n        int24 lowerTick,\n        int24 upperTick,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        uint256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256, int256);\n}"
    },
    "contracts/interfaces/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IUniswapV3SwapCallback {\n    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata data) external;\n}"
    },
    "contracts/lib/BitMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        r = 255;\n        if (x & type(uint128).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & type(uint64).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint32).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint8).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}"
    },
    "contracts/lib/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 2**96;\n}"
    },
    "contracts/lib/LiquidityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"prb-math/contracts/PRBMath.sol\";\nimport \"./FixedPoint96.sol\";\n\n\nlibrary LiquidityMath {\n    /// $L = \\frac{\\Delta x \\sqrt{P_u} \\sqrt{P_l}}{\\Delta \\sqrt{P}}$\n    function getLiquidityForAmount0(\n        uint160 sqrtPriceAX96,\n        uint160 sqrtPriceBX96,\n        uint256 amount0\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtPriceAX96 > sqrtPriceBX96)\n            (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        uint256 intermediate = PRBMath.mulDiv(\n            sqrtPriceAX96,\n            sqrtPriceBX96,\n            FixedPoint96.Q96\n        );\n        liquidity = uint128(\n            PRBMath.mulDiv(amount0, intermediate, sqrtPriceBX96 - sqrtPriceAX96)\n        );\n    }\n\n    /// $L = \\frac{\\Delta y}{\\Delta \\sqrt{P}}$\n    function getLiquidityForAmount1(\n        uint160 sqrtPriceAX96,\n        uint160 sqrtPriceBX96,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtPriceAX96 > sqrtPriceBX96)\n            (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        liquidity = uint128(\n            PRBMath.mulDiv(\n                amount1,\n                FixedPoint96.Q96,\n                sqrtPriceBX96 - sqrtPriceAX96\n            )\n        );\n    }\n\n    function getLiquidityForAmounts(\n        uint160 sqrtPriceX96,\n        uint160 sqrtPriceAX96,\n        uint160 sqrtPriceBX96,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtPriceAX96 > sqrtPriceBX96)\n            (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        if (sqrtPriceX96 <= sqrtPriceAX96) {\n            liquidity = getLiquidityForAmount0(\n                sqrtPriceAX96,\n                sqrtPriceBX96,\n                amount0\n            );\n        } else if (sqrtPriceX96 <= sqrtPriceBX96) {\n            uint128 liquidity0 = getLiquidityForAmount0(\n                sqrtPriceX96,\n                sqrtPriceBX96,\n                amount0\n            );\n            uint128 liquidity1 = getLiquidityForAmount1(\n                sqrtPriceAX96,\n                sqrtPriceX96,\n                amount1\n            );\n\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        } else {\n            liquidity = getLiquidityForAmount1(\n                sqrtPriceAX96,\n                sqrtPriceBX96,\n                amount1\n            );\n        }\n    }\n\n    /// 移除流动性时也调用这个方法，只不过此时 y 是负数\n    function addLiquidity(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            z = x - uint128(-y);\n        } else {\n            z = x + uint128(y);\n        }\n    }\n}"
    },
    "contracts/lib/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"./FixedPoint96.sol\";\nimport \"prb-math/contracts/PRBMath.sol\";\n\n\nlibrary Math {\n    /// @notice Calculates amount0 delta between two prices\n    function calcAmount0Delta(\n        uint160 sqrtPriceAX96,\n        uint160 sqrtPriceBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0) {\n        if (sqrtPriceAX96 > sqrtPriceBX96)\n            (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        require(sqrtPriceAX96 > 0);\n\n        amount0 = divRoundingUp(\n            mulDivRoundingUp(\n                (uint256(liquidity) << FixedPoint96.RESOLUTION),\n                (sqrtPriceBX96 - sqrtPriceAX96),\n                sqrtPriceBX96\n            ),\n            sqrtPriceAX96\n        );\n    }\n\n    /// @notice Calculates amount1 delta between two prices\n    /// TODO: round down when removing liquidity\n    function calcAmount1Delta(\n        uint160 sqrtPriceAX96,\n        uint160 sqrtPriceBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtPriceAX96 > sqrtPriceBX96)\n            (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96);\n\n        amount1 = mulDivRoundingUp(\n            liquidity,\n            (sqrtPriceBX96 - sqrtPriceAX96),\n            FixedPoint96.Q96\n        );\n    }\n\n    function getNextSqrtPriceFromInput(\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        uint256 amountIn,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtPriceNextX96) {\n        sqrtPriceNextX96 = zeroForOne\n            ? getNextSqrtPriceFromAmount0RoundingUp(\n                sqrtPriceX96,\n                liquidity,\n                amountIn\n            )\n            : getNextSqrtPriceFromAmount1RoundingDown(\n                sqrtPriceX96,\n                liquidity,\n                amountIn\n            );\n    }\n\n    function getNextSqrtPriceFromAmount0RoundingUp(\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        uint256 amountIn\n    ) internal pure returns (uint160) {\n        uint256 numerator = uint256(liquidity) << FixedPoint96.RESOLUTION;\n        uint256 product = amountIn * sqrtPriceX96;\n\n        // If product doesn't overflow, use the precise formula.\n        if (product / amountIn == sqrtPriceX96) {\n            uint256 denominator = numerator + product;\n            if (denominator >= numerator) {\n                return\n                    uint160(\n                        mulDivRoundingUp(numerator, sqrtPriceX96, denominator)\n                    );\n            }\n        }\n\n        // If product overflows, use a less precise formula.\n        return\n            uint160(\n                divRoundingUp(numerator, (numerator / sqrtPriceX96) + amountIn)\n            );\n    }\n\n    function getNextSqrtPriceFromAmount1RoundingDown(\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        uint256 amountIn\n    ) internal pure returns (uint160) {\n        return\n            sqrtPriceX96 +\n            uint160((amountIn << FixedPoint96.RESOLUTION) / liquidity);\n    }\n\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n\n    function divRoundingUp(uint256 numerator, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        assembly {\n            result := add(\n                div(numerator, denominator),\n                gt(mod(numerator, denominator), 0)\n            )\n        }\n    }\n}"
    },
    "contracts/lib/Position.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nlibrary Position {\n    struct Info {\n        uint128 liquidity;\n    }\n\n    function get(\n        mapping(bytes32 => Position.Info) storage self,\n        address owner,\n        int24 lowerTick,\n        int24 upperTick\n    ) internal view returns (Position.Info storage position) {\n        position = self[\n            keccak256(abi.encodePacked(owner, lowerTick, upperTick))\n        ];\n    }\n\n    function update(Info storage self, uint128 liquidityDelta) internal {\n        uint128 liquidityBefore = self.liquidity;\n        uint128 liquidityAfter = liquidityBefore + liquidityDelta;\n        self.liquidity = liquidityAfter;\n    }\n}"
    },
    "contracts/lib/SwapMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"./Math.sol\";\n\nlibrary SwapMath {\n    function computeSwapStep(\n        uint160 sqrtPriceCurrentX96,\n        uint160 sqrtPriceTargetX96,\n        uint128 liquidity,\n        uint256 amountRemaining\n    )\n        internal\n        pure\n        returns (uint160 sqrtPriceNextX96, uint256 amountIn, uint256 amountOut)\n    {\n        bool zeroForOne = sqrtPriceCurrentX96 >= sqrtPriceTargetX96;\n\n        amountIn = zeroForOne\n            ? Math.calcAmount0Delta(\n                sqrtPriceCurrentX96,\n                sqrtPriceTargetX96,\n                liquidity\n            )\n            : Math.calcAmount1Delta(\n                sqrtPriceCurrentX96,\n                sqrtPriceTargetX96,\n                liquidity\n            );\n\n        if (amountRemaining >= amountIn) {\n            // 此时说明当前 tick 区间不足以满足所有的交易金额，\n            sqrtPriceNextX96 = sqrtPriceTargetX96;\n        } else {\n            // 此时说明当前 tick 区间足以满足交易金额\n            // sqrtPriceCurrentX96 < sqrtPriceNextX96 < sqrtPriceTargetX96\n            sqrtPriceNextX96 = Math.getNextSqrtPriceFromInput(\n                sqrtPriceCurrentX96,\n                liquidity,\n                amountRemaining,\n                zeroForOne\n            );\n        }\n\n        amountIn = Math.calcAmount0Delta(\n            sqrtPriceCurrentX96,\n            sqrtPriceNextX96,\n            liquidity\n        );\n        amountOut = Math.calcAmount1Delta(\n            sqrtPriceCurrentX96,\n            sqrtPriceNextX96,\n            liquidity\n        );\n\n        if (!zeroForOne) {\n            (amountIn, amountOut) = (amountOut, amountIn);\n        }\n    }\n}\n"
    },
    "contracts/lib/Tick.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"./LiquidityMath.sol\";\n\nlibrary Tick {\n    struct Info {\n        bool initialized;\n        // total liquidity at tick\n        // 这个 tick 的总的 liquidity\n        uint128 liquidityGross;\n        // amount of liqudiity added or subtracted when tick is crossed\n        // 从左到右跨过这个 tick 是 liquidity 的增量，\n        int128 liquidityNet;\n    }\n\n    /// @param upper 是否是区间的上边界\n    function update(\n        mapping(int24 => Tick.Info) storage self,\n        int24 tick,\n        int128 liquidityDelta,\n        bool upper\n    ) internal returns (bool flipped) {\n        Tick.Info storage tickInfo = self[tick];\n        uint128 liquidityBefore = tickInfo.liquidityGross;\n        uint128 liquidityAfter = LiquidityMath.addLiquidity(liquidityBefore, liquidityDelta);\n\n        flipped = (liquidityAfter == 0) != (liquidityBefore == 0);\n\n        if (liquidityBefore == 0) {\n            tickInfo.initialized = true;\n        }\n\n        tickInfo.liquidityGross = liquidityAfter;\n        // 如果这个 tick 是区间的上边界，那么 从左到右 跨越这个 tick 时应该 - liquidityDelta\n        // 如果是下边界，那么 从左到右 跨越这个 tick 时应该 + liquidityDelta\n        tickInfo.liquidityNet = upper\n            ? int128(int256(tickInfo.liquidityNet) - liquidityDelta)\n            : int128(int256(tickInfo.liquidityNet) + liquidityDelta);\n    }\n\n    function cross(mapping(int24 => Tick.Info) storage self, int24 tick)\n        internal\n        view\n        returns (int128 liquidityDelta)\n    {\n        Tick.Info storage info = self[tick];\n        liquidityDelta = info.liquidityNet;\n    }\n}"
    },
    "contracts/lib/TickBitMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport './BitMath.sol';\n\n/// @title Packed tick initialized state library\n/// @notice Stores a packed mapping of tick index to its initialized state\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\nlibrary TickBitmap {\n\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\n    /// @param tick The tick for which to compute the position\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\n    /// @return bitPos The bit position in the word where the flag is stored\n    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {\n        wordPos = int16(tick >> 8);\n        bitPos = uint8(uint24(tick % 256));\n    }\n\n    /// 翻转位图中的某一位\n    /// @notice Flips the initialized state for a given tick from false to true, or vice versa\n    /// @param self The mapping in which to flip the tick\n    /// @param tick The tick to flip\n    /// @param tickSpacing The spacing between usable ticks\n    function flipTick(\n        mapping(int16 => uint256) storage self,\n        int24 tick,\n        int24 tickSpacing\n    ) internal {\n        require(tick % tickSpacing == 0); // ensure that the tick is spaced\n        (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\n        uint256 mask = 1 << bitPos;\n        self[wordPos] ^= mask;\n    }\n\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n    /// to the left (less than or equal to) or right (greater than) of the given tick\n    /// @param self The mapping in which to compute the next initialized tick\n    /// @param tick The starting tick\n    /// @param tickSpacing The spacing between usable ticks\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n    function nextInitializedTickWithinOneWord(\n        mapping(int16 => uint256) storage self,\n        int24 tick,\n        int24 tickSpacing,\n        bool lte\n    ) internal view returns (int24 next, bool initialized) {\n        int24 compressed = tick / tickSpacing;\n        if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\n\n        if (lte) {\n            // 卖出 token0（卖出x买入y），此时 tick 应该是逐渐变大的，\n            (int16 wordPos, uint8 bitPos) = position(compressed);\n            // all the 1s at or to the right of the current bitPos\n            uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\n            uint256 masked = self[wordPos] & mask;\n\n            // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n            initialized = masked != 0;\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n            next = initialized\n                ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing\n                : (compressed - int24(uint24(bitPos))) * tickSpacing;\n        } else {\n            // start from the word of the next tick, since the current tick state doesn't matter\n            (int16 wordPos, uint8 bitPos) = position(compressed + 1);\n            // all the 1s at or to the left of the bitPos\n            uint256 mask = ~((1 << bitPos) - 1);\n            uint256 masked = self[wordPos] & mask;\n\n            // if there are no initialized ticks to the left of the current tick, return leftmost in the word\n            initialized = masked != 0;\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n            next = initialized\n                ? (compressed + 1 + int24(uint24((BitMath.leastSignificantBit(masked) - bitPos)))) * tickSpacing\n                : (compressed + 1 + int24(uint24((type(uint8).max - bitPos)))) * tickSpacing;\n        }\n    }\n}\n\n"
    },
    "contracts/lib/TickMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(uint24(MAX_TICK)), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}"
    },
    "contracts/UniswapV3Manager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./lib/LiquidityMath.sol\";\nimport \"./lib/TickMath.sol\";\n\nimport \"./interfaces/IUniswapV3MintCallback.sol\";\nimport \"./interfaces/IUniswapV3SwapCallback.sol\";\nimport \"./interfaces/IUniswapV3Manager.sol\";\nimport \"./interfaces/IUniswapV3Pool.sol\";\n\ncontract UniswapV3Manager is IUniswapV3Manager, IUniswapV3MintCallback, IUniswapV3SwapCallback {\n    \n    error SlippageCheckFailed(uint256 amount0, uint256 amount1);\n\n    function mint(MintParams calldata params)\n        public\n        returns (uint256 amount0, uint256 amount1)\n    {\n        IUniswapV3Pool pool = IUniswapV3Pool(params.poolAddress);\n\n        (uint160 sqrtPriceX96, ) = pool.slot0();\n        uint160 sqrtPriceLowerX96 = TickMath.getSqrtRatioAtTick(params.lowerTick);\n        uint160 sqrtPriceUpperX96 = TickMath.getSqrtRatioAtTick(params.upperTick);\n\n        uint128 liquidity = LiquidityMath.getLiquidityForAmounts(\n            sqrtPriceX96,\n            sqrtPriceLowerX96,\n            sqrtPriceUpperX96,\n            params.amount0Desired,\n            params.amount1Desired\n        );\n\n        (amount0, amount1) = pool.mint(\n            msg.sender,\n            params.lowerTick,\n            params.upperTick,\n            liquidity,\n            abi.encode(IUniswapV3Pool.CallbackData(\n                {\n                    token0: pool.token0(),\n                    token1: pool.token1(),\n                    payer: msg.sender\n                })\n            )\n        );\n\n        if (amount0 < params.amount0Min || amount1 < params.amount1Min)\n            revert SlippageCheckFailed(amount0, amount1);\n    }\n\n    function uniswapV3MintCallback(uint256 amount0, uint256 amount1, bytes calldata data) override external {\n        IUniswapV3Pool.CallbackData memory extra = abi.decode(data, (IUniswapV3Pool.CallbackData));\n\n        // 增加流动性的回调，所以 amount0 和 amount1 都是 > 0\n        IERC20(extra.token0).transferFrom(extra.payer, msg.sender, amount0);\n        IERC20(extra.token1).transferFrom(extra.payer, msg.sender, amount1);\n    }\n\n    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata data) override external {\n        IUniswapV3Pool.CallbackData memory extra = abi.decode(data, (IUniswapV3Pool.CallbackData));\n\n        // 交易的回调函数，所以 amount0 > 0 时 amount1 < 0，或者 amount0 < 0 时 amount1 > 0\n        if (amount0 > 0) {\n            // 意味着需要调用者转账 amount0 的 token0 给 uniswapv3\n            IERC20(extra.token0).transferFrom(extra.payer, msg.sender, uint256(amount0));\n        }\n        if (amount1 > 0) {\n            IERC20(extra.token1).transferFrom(extra.payer, msg.sender, uint256(amount1));\n        }\n    }\n}"
    },
    "contracts/UniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./lib/Position.sol\";\nimport \"./lib/Tick.sol\";\nimport \"./lib/TickBitMap.sol\";\nimport \"./lib/Math.sol\";\nimport \"./lib/TickMath.sol\";\nimport \"./lib/SwapMath.sol\";\nimport \"./lib/LiquidityMath.sol\";\n\nimport \"./interfaces/IUniswapV3MintCallback.sol\";\nimport \"./interfaces/IUniswapV3SwapCallback.sol\";\nimport \"./interfaces/IUniswapV3Pool.sol\";\n\ncontract UniswapV3Pool is IUniswapV3Pool {\n    error InvalidTickRange();\n    error ZeroLiquidity();\n    error InsufficientInputAmount();\n    error NotEnoughLiquidity();\n    error InvalidPriceLimit();\n\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    event Log(uint256 amount0, uint256 amount1);\n\n    using Tick for mapping(int24 => Tick.Info);\n    using TickBitmap for mapping(int16 => uint256);\n    using Position for mapping(bytes32 => Position.Info);\n    using Position for Position.Info;\n\n    int24 internal constant MIN_TICK = -887272;\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    address public immutable token0;\n    address public immutable token1;\n\n    // 当前 swap 的状态\n    struct SwapState {\n        // 待交换的 tokenIn 的金额\n        uint256 amountSpecifiedRemaining;\n        // 已交换的 tokenOut 的金额\n        uint256 amountCalculated;\n        // 当前 swap 交易结束后的价格\n        uint160 sqrtPriceX96;\n        // 当前 swap 交易结束后的 tick\n        int24 tick;\n        uint128 liquidity;\n    }\n\n    // 维护当前交易”一步“的状态\n    struct StepState {\n        // 循环开始时的价格\n        uint160 sqrtPriceStartX96;\n        // 能够为交易提供流动性的下一个已初始化的tick\n        int24 nextTick;\n        // 下一个 tick 的价格\n        uint160 sqrtPriceNextX96;\n        // amountIn 和 amountOut 是当前循环中流动性能够提供的数量\n        uint256 amountIn;\n        uint256 amountOut;\n        bool initialized;\n    }\n\n    struct Slot0 {\n        // 当前价格\n        uint160 sqrtPriceX96;\n        // 当前 tick\n        int24 tick;\n    }\n    Slot0 public slot0;\n\n    // 总的流动性\n    uint128 public liquidity;\n\n    mapping(int24 => Tick.Info) public ticks;\n    // tick 的位图，tick是 int24（24bit的int），tick的前16位是 key，用于从 map 中找到对应的 value（位图）\n    // tick的后8位是位图的key，2 ** 8 的范围为 [0, 255]，表示 value 中哪一个位\n    mapping(int16 => uint256) public tickBitmap;\n    mapping(bytes32 => Position.Info) positions;\n\n    constructor(\n        address token0_,\n        address token1_,\n        uint160 sqrtPriceX96,\n        int24 tick\n    ) {\n        token0 = token0_;\n        token1 = token1_;\n\n        slot0 = Slot0({sqrtPriceX96: sqrtPriceX96, tick: tick});\n    }\n\n    // 提供流动性\n    function mint(\n        address owner,\n        int24 lowerTick,\n        int24 upperTick,\n        uint128 amount,\n        bytes calldata data\n    ) external override returns (uint256 amount0, uint256 amount1) {\n        if (lowerTick >= upperTick || lowerTick < TickMath.MIN_TICK || upperTick > TickMath.MAX_TICK) {\n            revert InvalidTickRange();\n        } \n        if (amount <= 0) {\n            revert ZeroLiquidity();\n        }\n\n        bool flippedLower = ticks.update(lowerTick, int128(amount), false);\n        bool flippedUpper = ticks.update(upperTick, int128(amount), true);\n\n\n        if (flippedLower) {\n            tickBitmap.flipTick(lowerTick, 1);\n        }\n\n        if (flippedUpper) {\n            tickBitmap.flipTick(upperTick, 1);\n        }\n\n        Position.Info storage position = positions.get(owner, lowerTick, upperTick);\n        position.update(amount);\n\n        Slot0 memory slot0_ = slot0;\n\n        if (slot0_.tick < lowerTick) {\n            // 价格区间在当前 tick 右边，此时提供的流动性应全部由 token0 提供\n            amount0 = Math.calcAmount0Delta(\n                TickMath.getSqrtRatioAtTick(lowerTick),\n                TickMath.getSqrtRatioAtTick(upperTick),\n                amount\n            );\n        } else if (slot0_.tick < upperTick) {\n            // 价格区间包含当前 tick\n            amount0 = Math.calcAmount0Delta(\n                slot0_.sqrtPriceX96,\n                TickMath.getSqrtRatioAtTick(upperTick),\n                amount\n            );\n\n            amount1 = Math.calcAmount1Delta(\n                slot0_.sqrtPriceX96,\n                TickMath.getSqrtRatioAtTick(lowerTick),\n                amount\n            );\n\n            liquidity = LiquidityMath.addLiquidity(liquidity, int128(amount));\n        } else {\n            // 价格区间在当前 tick 左边，此时提供的流动性应全部由 token1 提供\n            amount1 = Math.calcAmount1Delta(\n                TickMath.getSqrtRatioAtTick(lowerTick),\n                TickMath.getSqrtRatioAtTick(upperTick),\n                amount\n            );\n        }\n\n        uint256 balance0Before;\n        uint256 balance1Before;\n        if (amount0 > 0) {\n            balance0Before = balance0();\n        }\n        if (amount1 > 0) {\n            balance1Before = balance1();\n        }\n        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);\n        if (amount0 > 0 && balance0Before + amount0 > balance0()) {\n            revert InsufficientInputAmount();\n        }\n        if (amount1 > 0 && balance1Before + amount1 > balance1()) {\n            revert InsufficientInputAmount();\n        }\n        emit Mint(msg.sender, owner, lowerTick, upperTick, amount, amount0, amount1);\n    }\n\n    /// @param zeroForOne 用来控制交易方向的 flag：当设置为 true，是用 token0 兑换 token1；false 则相反。例如，如果 token0 是ETH，token1 是USDC，将 zeroForOne 设置为 true 意味着用 ETH 购买 USDC\n    /// @param amountSpecified 用户希望卖出的 token 数量\n    /// @param sqrtPriceLimitX96 滑点保护，当 zeroForOne 为 true 时，交易的价格不能低于 sqrtPriceLimitX96；当 zeroForOne 为 false 时，交易的价格不能高于 sqrtPriceLimitX96\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        uint256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external override returns (int256 amount0, int256 amount1) {\n        // Caching for gas saving\n        Slot0 memory slot0_ = slot0;\n        uint128 liquidity_ = liquidity;\n\n        if (zeroForOne\n                ? sqrtPriceLimitX96 > slot0_.sqrtPriceX96 || sqrtPriceLimitX96 < TickMath.MIN_SQRT_RATIO\n                : sqrtPriceLimitX96 < slot0_.sqrtPriceX96 || sqrtPriceLimitX96 > TickMath.MAX_SQRT_RATIO\n        ) {\n            revert InvalidPriceLimit();\n        }\n\n        SwapState memory state = SwapState({\n            amountSpecifiedRemaining: amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: slot0_.sqrtPriceX96,\n            tick: slot0_.tick,\n            liquidity: liquidity_\n        });\n\n        while (\n            state.amountSpecifiedRemaining > 0 &&\n            state.sqrtPriceX96 != sqrtPriceLimitX96\n        ) {\n            StepState memory step;\n\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.nextTick, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(\n                state.tick,\n                1,\n                zeroForOne\n            );\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.nextTick);\n\n            (state.sqrtPriceX96, step.amountIn, step.amountOut) = SwapMath.computeSwapStep(\n                    state.sqrtPriceX96,\n                    (zeroForOne\n                            ? step.sqrtPriceNextX96 < sqrtPriceLimitX96\n                            : step.sqrtPriceNextX96 > sqrtPriceLimitX96\n                    )\n                        ? sqrtPriceLimitX96\n                        : step.sqrtPriceNextX96,\n                    state.liquidity,\n                    state.amountSpecifiedRemaining\n                );\n\n            state.amountSpecifiedRemaining -= step.amountIn;\n            state.amountCalculated += step.amountOut;\n\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                if (step.initialized) {\n                    int128 liquidityDelta = ticks.cross(step.nextTick);\n\n                    // 当 zeroForOne 为 true，也就是从右往左略过 tick，\n                    // liquidityDelta 表示从左到右略过 tick 是 liquidity 的变化量，所以应该取负\n                    if (zeroForOne) {\n                        liquidityDelta = -liquidityDelta;\n                    }\n\n                    state.liquidity = LiquidityMath.addLiquidity(state.liquidity, liquidityDelta);\n\n                    if (state.liquidity == 0) {\n                        revert NotEnoughLiquidity();\n                    }\n                }\n\n                state.tick = zeroForOne ? step.nextTick - 1 : step.nextTick;\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n            }\n        }\n\n        if (state.tick != slot0_.tick) {\n            (slot0.sqrtPriceX96, slot0.tick) = (state.sqrtPriceX96, state.tick);\n        }\n\n        if (liquidity_ != state.liquidity) {\n            liquidity = state.liquidity;\n        }        \n\n        (amount0, amount1) = zeroForOne\n            ? (\n                int256(amountSpecified - state.amountSpecifiedRemaining),\n                -int256(state.amountCalculated)\n            )\n            : (\n                -int256(state.amountCalculated),\n                int256(amountSpecified - state.amountSpecifiedRemaining)\n            );\n\n        if (zeroForOne) {\n            IERC20(token1).transfer(recipient, uint256(-amount1));\n\n            uint256 balance0Before = balance0();\n            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(\n                amount0,\n                amount1,\n                data\n            );\n            if (balance0Before + uint256(amount0) > balance0())\n                revert InsufficientInputAmount();\n        } else {\n            IERC20(token0).transfer(recipient, uint256(-amount0));\n\n            uint256 balance1Before = balance1();\n            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(\n                amount0,\n                amount1,\n                data\n            );\n            if (balance1Before + uint256(amount1) > balance1())\n                revert InsufficientInputAmount();\n        }\n\n        emit Swap(\n            msg.sender,\n            recipient,\n            amount0,\n            amount1,\n            slot0.sqrtPriceX96,\n            state.liquidity,\n            slot0.tick\n        );\n    }\n\n    function balance0() internal view returns (uint256) {\n        return IERC20(token0).balanceOf(address(this));\n    }\n\n    function balance1() internal view returns (uint256) {\n        return IERC20(token1).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/UniswapV3Quoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n\nimport \"./interfaces/IUniswapV3Pool.sol\";\nimport \"./lib/TickMath.sol\";\n\ncontract UniswapV3Quoter {\n    struct QuoteParams {\n        address pool;\n        uint256 amountIn;\n        uint160 sqrtPriceLimitX96;\n        bool zeroForOne;\n    }\n\n    function quote(QuoteParams memory params)\n        public\n        returns (\n            uint256 amountOut,\n            uint160 sqrtPriceX96After,\n            int24 tickAfter\n        )\n    {\n        try\n            IUniswapV3Pool(params.pool).swap(\n                address(this),\n                params.zeroForOne,\n                params.amountIn,\n                params.sqrtPriceLimitX96 == 0\n                    ? (params.zeroForOne\n                            ? TickMath.MIN_SQRT_RATIO + 1\n                            : TickMath.MAX_SQRT_RATIO - 1\n                    )\n                    : params.sqrtPriceLimitX96,\n                abi.encode(params.pool)\n            )\n        {} catch (bytes memory reason) {\n            return abi.decode(reason, (uint256, uint160, int24));\n        }\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes memory data\n    ) external view {\n        address pool = abi.decode(data, (address));\n\n        uint256 amountOut = amount0Delta > 0\n            ? uint256(-amount1Delta)\n            : uint256(-amount0Delta);\n\n        (uint160 sqrtPriceX96After, int24 tickAfter) = IUniswapV3Pool(pool)\n            .slot0();\n\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, amountOut)\n            mstore(add(ptr, 0x20), sqrtPriceX96After)\n            mstore(add(ptr, 0x40), tickAfter)\n            revert(ptr, 96)\n        }\n    }\n}"
    },
    "prb-math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}